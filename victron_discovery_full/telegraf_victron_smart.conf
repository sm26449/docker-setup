# Telegraf Configuration - Victron Energy
# Optimized for easy InfluxDB queries
#
# Structure:
#   measurement = device_type (battery, grid, vebus, system, pvinverter, temperature)
#   tags:
#     - instance: device instance ID (512, 274, 0, etc.)
#     - metric: full path as underscore-separated (Ac_L1_Power, Dc_0_Current, etc.)
#   field:
#     - value: the actual measurement value
#
# Query examples:
#   SELECT value FROM grid WHERE metric = 'Ac_L1_Power'
#   SELECT value FROM battery WHERE instance = '512' AND metric = 'Soc'
#   SELECT value FROM pvinverter WHERE metric =~ /Ac_L.*_Power/

[global_tags]
  source = "victron"
  portal_id = "c0619ab7d12b"

[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  flush_interval = "10s"
  hostname = ""
  omit_hostname = true

###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################

[[outputs.influxdb_v2]]
  urls = ["http://influxdb:8086"]
  token = "O41TdfnFuTmr2zBinGgaBIxEw9zib1HW"
  organization = "pv-stack"
  bucket = "victron"

###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Main Victron MQTT Consumer
[[inputs.mqtt_consumer]]
  servers = ["ssl://192.168.88.250:8883"]
  client_id = "telegraf-victron"
  qos = 0
  connection_timeout = "30s"
  persistent_session = true

  username = "admin"
  password = "rbdc9vtrc8"
  insecure_skip_verify = true

  # Subscribe to important device types only (skip settings, platform, etc.)
  topics = [
    "N/c0619ab7d12b/battery/#",
    "N/c0619ab7d12b/grid/#",
    "N/c0619ab7d12b/vebus/#",
    "N/c0619ab7d12b/system/#",
    "N/c0619ab7d12b/pvinverter/#",
    "N/c0619ab7d12b/temperature/#",
    "N/c0619ab7d12b/hub4/#",
  ]

  # Victron sends {"value": X}
  data_format = "json"

  # 5 parts: N/portal/type/instance/metric
  # Example: N/xxx/battery/512/Soc -> battery, instance=512, metric=Soc
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+"
    measurement = "_/_/measurement/_/_"
    tags = "_/_/_/instance/metric"

  # 6 parts: N/portal/type/instance/p1/p2
  # Example: N/xxx/grid/0/Ac/Power -> grid, instance=0, metric=Ac_Power
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+/+"
    measurement = "_/_/measurement/_/_/_"
    tags = "_/_/_/instance/p1/p2"

  # 7 parts: N/portal/type/instance/p1/p2/p3
  # Example: N/xxx/grid/0/Ac/L1/Power -> grid, instance=0, metric=Ac_L1_Power
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+/+/+"
    measurement = "_/_/measurement/_/_/_/_"
    tags = "_/_/_/instance/p1/p2/p3"

  # 8 parts: N/portal/type/instance/p1/p2/p3/p4
  # Example: N/xxx/vebus/274/Ac/Out/L1/P -> vebus, instance=274, metric=Ac_Out_L1_P
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+/+/+/+"
    measurement = "_/_/measurement/_/_/_/_/_"
    tags = "_/_/_/instance/p1/p2/p3/p4"

  # 9 parts: N/portal/type/instance/p1/p2/p3/p4/p5
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+/+/+/+/+"
    measurement = "_/_/measurement/_/_/_/_/_/_"
    tags = "_/_/_/instance/p1/p2/p3/p4/p5"

  # 10 parts
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+/+/+/+/+/+"
    measurement = "_/_/measurement/_/_/_/_/_/_/_"
    tags = "_/_/_/instance/p1/p2/p3/p4/p5/p6"

###############################################################################
#                          PROCESSOR PLUGINS                                  #
###############################################################################

# Combine path parts into single 'metric' tag
[[processors.starlark]]
  namepass = ["battery", "grid", "vebus", "system", "pvinverter", "temperature", "hub4"]

  source = '''
def apply(metric):
    # Collect path parts
    parts = []
    for key in ["p1", "p2", "p3", "p4", "p5", "p6"]:
        val = metric.tags.get(key)
        if val:
            parts.append(val)
            metric.tags.pop(key)

    # If we have path parts, create combined metric tag
    if parts:
        # Check if there's already a 'metric' tag (from 5-part topics)
        existing = metric.tags.get("metric")
        if existing:
            parts.insert(0, existing)
        metric.tags["metric"] = "_".join(parts)

    return metric
'''

# Filter out non-numeric values (strings like "Connected", "ProductName", etc.)
[[processors.converter]]
  namepass = ["battery", "grid", "vebus", "system", "pvinverter", "temperature", "hub4"]

  [processors.converter.fields]
    float = ["value"]
