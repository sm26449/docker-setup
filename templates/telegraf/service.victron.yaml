name: telegraf_victron
description: "Telegraf - Victron Energy MQTT (via local bridge or direct Venus OS connection)"

dependencies:
  - name: influxdb
    variables:
      TELEGRAF_INFLUXDB_URL: "http://${HOST}:${PORT}"
  - name: mosquitto_victron
    optional: true
    variables:
      TELEGRAF_MQTT_SERVER: "tcp://${HOST}:${PORT}"
      TELEGRAF_MQTT_USERNAME: "${MQTT_USERNAME}"
      TELEGRAF_MQTT_PASSWORD: "${MQTT_PASSWORD}"
      VICTRON_PORTAL_ID: "${VENUS_PORTAL_ID}"

variables:
  # Collection interval
  TELEGRAF_INTERVAL:
    default: "10s"
    description: "Metrics collection interval"

  # InfluxDB 2.x settings
  TELEGRAF_INFLUXDB_URL:
    default: "http://influxdb:8086"
    description: "InfluxDB URL"
    prompt: true

  TELEGRAF_INFLUXDB_TOKEN:
    default: ""
    description: "InfluxDB API token"
    prompt: true

  TELEGRAF_INFLUXDB_ORG:
    default: "homelab"
    description: "InfluxDB organization"
    prompt: true

  TELEGRAF_INFLUXDB_BUCKET:
    default: "victron"
    description: "InfluxDB bucket for Victron data"
    prompt: true

  # MQTT settings
  TELEGRAF_MQTT_SERVER:
    default: "tcp://mosquitto-victron:1883"
    description: "MQTT server URL (use local bridge: tcp://mosquitto-victron:1883, or direct: ssl://venus.local:8883)"
    prompt: true

  TELEGRAF_MQTT_USERNAME:
    default: ""
    description: "MQTT username (leave empty if not required)"
    prompt: true

  TELEGRAF_MQTT_PASSWORD:
    default: ""
    description: "MQTT password"
    prompt: true

  TELEGRAF_MQTT_INSECURE:
    default: "true"
    description: "Skip TLS verification (Venus uses self-signed certs)"

  # Victron specific
  VICTRON_PORTAL_ID:
    default: ""
    description: "VRM Portal ID (12 hex chars, find in Venus OS: Settings → VRM Online Portal)"
    prompt: true

  VICTRON_MONITOR_BATTERY:
    default: "true"
    description: "Monitor battery (BMV/SmartShunt)"
    prompt: true

  VICTRON_MONITOR_GRID:
    default: "true"
    description: "Monitor grid meter"
    prompt: true

  VICTRON_MONITOR_PVINVERTER:
    default: "true"
    description: "Monitor PV inverter (Fronius/SMA)"
    prompt: true

  VICTRON_MONITOR_VEBUS:
    default: "true"
    description: "Monitor inverter/charger (MultiPlus/Quattro)"
    prompt: true

  VICTRON_MONITOR_SYSTEM:
    default: "true"
    description: "Monitor system overview"
    prompt: true

  VICTRON_MONITOR_SOLARCHARGER:
    default: "false"
    description: "Monitor MPPT solar charger"

  VICTRON_MONITOR_TEMPERATURE:
    default: "true"
    description: "Monitor temperature sensors"

hooks:
  post_deploy:
    # Create InfluxDB bucket for Victron data
    - "docker exec ${STACK}-influxdb influx bucket create -n '${TELEGRAF_INFLUXDB_BUCKET}' -o '${TELEGRAF_INFLUXDB_ORG}' 2>/dev/null && echo '✓ InfluxDB bucket ${TELEGRAF_INFLUXDB_BUCKET} created' || true"

config_files:
  - path: "config/telegraf.conf"
    content: |
      # Telegraf Configuration - Victron Energy
      # Optimized for easy InfluxDB queries
      #
      # Structure:
      #   measurement = device_type (battery, grid, vebus, system, pvinverter, temperature)
      #   tags:
      #     - instance: device instance ID (512, 274, 0, etc.)
      #     - metric: full path as underscore-separated (Ac_L1_Power, Dc_0_Current, etc.)
      #   field:
      #     - value: the actual measurement value
      #
      # Query examples:
      #   SELECT value FROM grid WHERE metric = 'Ac_L1_Power'
      #   SELECT value FROM battery WHERE instance = '512' AND metric = 'Soc'
      #   SELECT value FROM pvinverter WHERE metric =~ /Ac_L.*_Power/

      [global_tags]
        source = "victron"
        portal_id = "${VICTRON_PORTAL_ID}"

      [agent]
        interval = "${TELEGRAF_INTERVAL}"
        round_interval = true
        metric_batch_size = 1000
        metric_buffer_limit = 10000
        flush_interval = "10s"
        hostname = ""
        omit_hostname = true

      ###############################################################################
      #                            OUTPUT PLUGINS                                   #
      ###############################################################################

      [[outputs.influxdb_v2]]
        urls = ["${TELEGRAF_INFLUXDB_URL}"]
        token = "${TELEGRAF_INFLUXDB_TOKEN}"
        organization = "${TELEGRAF_INFLUXDB_ORG}"
        bucket = "${TELEGRAF_INFLUXDB_BUCKET}"

      ###############################################################################
      #                            INPUT PLUGINS                                    #
      ###############################################################################

      # Main Victron MQTT Consumer
      [[inputs.mqtt_consumer]]
        servers = ["${TELEGRAF_MQTT_SERVER}"]
        client_id = "telegraf-victron"
        qos = 0
        connection_timeout = "30s"
        persistent_session = true

        username = "${TELEGRAF_MQTT_USERNAME}"
        password = "${TELEGRAF_MQTT_PASSWORD}"
        insecure_skip_verify = true

        # Subscribe to important device types only (skip settings, platform, etc.)
        topics = [
          "N/${VICTRON_PORTAL_ID}/battery/#",
          "N/${VICTRON_PORTAL_ID}/grid/#",
          "N/${VICTRON_PORTAL_ID}/vebus/#",
          "N/${VICTRON_PORTAL_ID}/system/#",
          "N/${VICTRON_PORTAL_ID}/pvinverter/#",
          "N/${VICTRON_PORTAL_ID}/temperature/#",
          "N/${VICTRON_PORTAL_ID}/hub4/#",
        ]

        # Victron sends {"value": X}
        data_format = "json"

        # 5 parts: N/portal/type/instance/metric
        # Example: N/xxx/battery/512/Soc -> battery, instance=512, metric=Soc
        [[inputs.mqtt_consumer.topic_parsing]]
          topic = "N/+/+/+/+"
          measurement = "_/_/measurement/_/_"
          tags = "_/_/_/instance/metric"

        # 6 parts: N/portal/type/instance/p1/p2
        # Example: N/xxx/grid/0/Ac/Power -> grid, instance=0, metric=Ac_Power
        [[inputs.mqtt_consumer.topic_parsing]]
          topic = "N/+/+/+/+/+"
          measurement = "_/_/measurement/_/_/_"
          tags = "_/_/_/instance/p1/p2"

        # 7 parts: N/portal/type/instance/p1/p2/p3
        # Example: N/xxx/grid/0/Ac/L1/Power -> grid, instance=0, metric=Ac_L1_Power
        [[inputs.mqtt_consumer.topic_parsing]]
          topic = "N/+/+/+/+/+/+"
          measurement = "_/_/measurement/_/_/_/_"
          tags = "_/_/_/instance/p1/p2/p3"

        # 8 parts: N/portal/type/instance/p1/p2/p3/p4
        # Example: N/xxx/vebus/274/Ac/Out/L1/P -> vebus, instance=274, metric=Ac_Out_L1_P
        [[inputs.mqtt_consumer.topic_parsing]]
          topic = "N/+/+/+/+/+/+/+"
          measurement = "_/_/measurement/_/_/_/_/_"
          tags = "_/_/_/instance/p1/p2/p3/p4"

        # 9 parts: N/portal/type/instance/p1/p2/p3/p4/p5
        [[inputs.mqtt_consumer.topic_parsing]]
          topic = "N/+/+/+/+/+/+/+/+"
          measurement = "_/_/measurement/_/_/_/_/_/_"
          tags = "_/_/_/instance/p1/p2/p3/p4/p5"

        # 10 parts
        [[inputs.mqtt_consumer.topic_parsing]]
          topic = "N/+/+/+/+/+/+/+/+/+"
          measurement = "_/_/measurement/_/_/_/_/_/_/_"
          tags = "_/_/_/instance/p1/p2/p3/p4/p5/p6"

      ###############################################################################
      #                          PROCESSOR PLUGINS                                  #
      ###############################################################################

      # Combine path parts into single 'metric' tag
      [[processors.starlark]]
        namepass = ["battery", "grid", "vebus", "system", "pvinverter", "temperature", "hub4"]

        source = '''
      def apply(metric):
          # Collect path parts
          parts = []
          for key in ["p1", "p2", "p3", "p4", "p5", "p6"]:
              val = metric.tags.get(key)
              if val:
                  parts.append(val)
                  metric.tags.pop(key)

          # If we have path parts, create combined metric tag
          if parts:
              # Check if there's already a 'metric' tag (from 5-part topics)
              existing = metric.tags.get("metric")
              if existing:
                  parts.insert(0, existing)
              metric.tags["metric"] = "_".join(parts)

          return metric
      '''

      # Filter out non-numeric values (strings like "Connected", "ProductName", etc.)
      [[processors.converter]]
        namepass = ["battery", "grid", "vebus", "system", "pvinverter", "temperature", "hub4"]

        [processors.converter.fields]
          float = ["value"]

compose: |
  telegraf-victron:
    image: telegraf:latest
    container_name: telegraf-victron
    restart: unless-stopped
    hostname: telegraf-victron
    environment:
      - TELEGRAF_INTERVAL=${TELEGRAF_INTERVAL:-10s}
      - TELEGRAF_INFLUXDB_URL=${TELEGRAF_INFLUXDB_URL}
      - TELEGRAF_INFLUXDB_TOKEN=${TELEGRAF_INFLUXDB_TOKEN}
      - TELEGRAF_INFLUXDB_ORG=${TELEGRAF_INFLUXDB_ORG}
      - TELEGRAF_INFLUXDB_BUCKET=${TELEGRAF_INFLUXDB_BUCKET}
      - TELEGRAF_MQTT_SERVER=${TELEGRAF_MQTT_SERVER}
      - VICTRON_PORTAL_ID=${VICTRON_PORTAL_ID:-+}
    volumes:
      - ${DOCKER_ROOT}/telegraf-victron/config/telegraf.conf:/etc/telegraf/telegraf.conf:ro
    healthcheck:
      test: ["CMD", "telegraf", "--test"]
      interval: 60s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
