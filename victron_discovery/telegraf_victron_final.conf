# Telegraf Configuration for Victron Energy - Optimized for InfluxDB
# Auto-generated based on discovered topics from Venus OS
# Portal ID: c0619ab7d12b
#
# STRUCTURE:
# - Each device type becomes a measurement (battery, grid, vebus, system, etc.)
# - instance tag identifies the specific device
# - Field names are derived from the MQTT path (e.g., Dc/0/Power -> Dc_0_Power)
#
# QUERY EXAMPLES:
#   SELECT Dc_0_Power FROM battery WHERE instance = '512'
#   SELECT Ac_Power FROM grid
#   SELECT Temperature FROM temperature WHERE instance = '22'

[global_tags]
  portal_id = "c0619ab7d12b"
  source = "victron"

[agent]
  interval = "10s"
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  flush_interval = "10s"
  flush_jitter = "2s"
  precision = "1s"
  hostname = ""
  omit_hostname = true

###############################################################################
#                            OUTPUT PLUGINS                                   #
###############################################################################

[[outputs.influxdb_v2]]
  urls = ["${TELEGRAF_INFLUXDB_URL}"]
  token = "${TELEGRAF_INFLUXDB_TOKEN}"
  organization = "${TELEGRAF_INFLUXDB_ORG}"
  bucket = "${TELEGRAF_INFLUXDB_BUCKET}"

  # Exclude string values that can't be graphed
  fieldexclude = ["*_str"]

# Debug output (disable in production)
# [[outputs.file]]
#   files = ["stdout"]

###############################################################################
#                            INPUT PLUGINS                                    #
###############################################################################

# Main Victron MQTT Consumer
# Subscribes to all device types and uses Starlark processor to flatten paths
[[inputs.mqtt_consumer]]
  servers = ["${TELEGRAF_MQTT_SERVER}"]

  client_id = "telegraf-victron"
  qos = 0
  connection_timeout = "30s"

  username = "${TELEGRAF_MQTT_USERNAME}"
  password = "${TELEGRAF_MQTT_PASSWORD}"

  # TLS for Venus OS (self-signed certs)
  insecure_skip_verify = true

  topics = [
    "N/${VICTRON_PORTAL_ID}/battery/#",
    "N/${VICTRON_PORTAL_ID}/grid/#",
    "N/${VICTRON_PORTAL_ID}/vebus/#",
    "N/${VICTRON_PORTAL_ID}/system/#",
    "N/${VICTRON_PORTAL_ID}/pvinverter/#",
    "N/${VICTRON_PORTAL_ID}/temperature/#",
    "N/${VICTRON_PORTAL_ID}/solarcharger/#",
    "N/${VICTRON_PORTAL_ID}/hub4/#",
    "N/${VICTRON_PORTAL_ID}/vecan/#",
  ]

  data_format = "json_v2"

  [[inputs.mqtt_consumer.json_v2]]
    [[inputs.mqtt_consumer.json_v2.field]]
      path = "value"
      type = "float"
      optional = true

  # Topic parsing - extract device_type as measurement
  # Pattern: N/<portal_id>/<device_type>/<instance>/<path...>

  # 5-part topics: N/portal/type/instance/field
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+"
    measurement = "_/_/measurement/_/_"
    tags = "_/_/_/instance/_"
    fields = "_/_/_/_/field_path"

  # 6-part topics: N/portal/type/instance/path1/path2
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+/+"
    measurement = "_/_/measurement/_/_/_"
    tags = "_/_/_/instance/_/_"
    fields = "_/_/_/_/p1/p2"

  # 7-part topics: N/portal/type/instance/path1/path2/path3
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+/+/+"
    measurement = "_/_/measurement/_/_/_/_"
    tags = "_/_/_/instance/_/_/_"
    fields = "_/_/_/_/p1/p2/p3"

  # 8-part topics: N/portal/type/instance/path1/path2/path3/path4
  [[inputs.mqtt_consumer.topic_parsing]]
    topic = "N/+/+/+/+/+/+/+"
    measurement = "_/_/measurement/_/_/_/_/_"
    tags = "_/_/_/instance/_/_/_/_"
    fields = "_/_/_/_/p1/p2/p3/p4"

###############################################################################
#                          PROCESSOR PLUGINS                                  #
###############################################################################

# Flatten the path fields into a single field name
[[processors.starlark]]
  namepass = ["battery", "grid", "vebus", "system", "pvinverter", "temperature", "solarcharger", "hub4", "vecan"]

  source = '''
def apply(metric):
    # Build field name from path components
    parts = []
    for key in ["field_path", "p1", "p2", "p3", "p4"]:
        val = metric.fields.get(key)
        if val and val != "":
            parts.append(str(val))

    if not parts:
        return metric

    # Create flattened field name (e.g., Dc_0_Power)
    field_name = "_".join(parts)

    # Get the actual value
    value = metric.fields.get("value")

    # Remove path components and original value field
    for key in ["field_path", "p1", "p2", "p3", "p4", "value"]:
        if key in metric.fields:
            metric.fields.pop(key)

    # Add the value with the flattened field name
    if value is not None:
        metric.fields[field_name] = value

    return metric
'''

# Convert any remaining string values for numeric fields
[[processors.converter]]
  namepass = ["battery", "grid", "vebus", "system", "pvinverter", "temperature", "solarcharger", "hub4"]

  [processors.converter.fields]
    float = ["*Power*", "*Voltage*", "*Current*", "*Temperature*", "*Soc*", "*Energy*"]

# Aggregate metrics to reduce cardinality
# Group by measurement and instance, output every 10s
[[aggregators.basicstats]]
  namepass = ["battery", "grid", "vebus", "system"]
  period = "30s"
  drop_original = false
  stats = ["mean", "min", "max"]

###############################################################################
#                     ALTERNATIVE: SIMPLIFIED CONFIG                          #
###############################################################################
# If the Starlark processor causes issues, use this simpler approach:
# Each value stays as "value" field, with path info in tags.
# Query example: SELECT value FROM battery WHERE field = 'Dc' AND subfield = '0' AND metric = 'Power'
#
# Uncomment below and comment out the Starlark section above:
#
# [[processors.rename]]
#   namepass = ["battery", "grid", "vebus", "system", "pvinverter", "temperature"]
#   [[processors.rename.replace]]
#     field = "value"
#     dest = "measurement_value"
